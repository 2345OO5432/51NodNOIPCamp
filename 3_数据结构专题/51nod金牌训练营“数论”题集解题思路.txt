1060
最复杂的数  
显然只会用到最小的那几个素数，直接搜索每个素数用几次幂就可以了

1179最大的最大公约数 
实际上就是求最大的公约数。对于每个数，找到n个数里有多少个是其倍数，超过两个都行

1434区间LCM 
对每个素数单独做，看看1到N中最高幂次是多少，决定M至少有多大

1186质数检测 V2 
Miller-Rabin测试

1040最大公约数之和 
枚举最大公约数d，则和n的gcd为d的数字数量为phi(n/d)，phi为欧拉函数

1217Minimum Modular 
对于每一对数，算出差，就知道哪些M会让这一对数冲突。由于最多可以删除K个数，移除(k+1)k/2对冲突，那么只需要枚举M并把冲突对拿出来计算就可以了

1616最小集合 
就是求所有可能成为这n个数字gcd的数。先求出每个数字的倍数数量，再和其倍数比较，判断是否可能为gcd。

1225余数之和
 n%i=n-(n/i)*i，这里的除法下取整。而n/i只有根号种，枚举即可。

1187寻找分数 
去掉分数的整数部分意味着a%b,c%d，再进行a/b<p/q<c/d -> d/c<q/p<b/a的交换，迭代下去类似gcd，复杂度为O(log(a+b+c+d))

1594Gcd and Phi 
先求出phi，再求出fi表示i是gcd(phi(a),phi(b))因子的(a,b)对数，对f进行莫比乌斯反演即可得到i是gcd(phi(a),phi(b))的(a,b)对数，再直接求答案。